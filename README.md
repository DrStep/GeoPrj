ДЗ-1
По результатам первого занятия у всех групп уже должен быть: 
1. свой репозиторий в github.com, «сфорканный» у каждого участника группы. 
2. В каждом репозитории должен быть проект для intelij idea под управлением maven. 
3. В проекте должен быть класс Main c функцией main который можно скомпилировать и запустить. После запуска приложение должно написать в лог «Hello!»
4. В pom.xml должны быть добавлены зависимости на jetty и freemarker:

<dependency>
    <groupId>org.eclipse.jetty</groupId>
    <artifactId>jetty-server</artifactId>
    <version>9.0.5.v20130815</version>        
</dependency>  
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.19</version>
</dependency>

Если все это работает изучайте:
wiki.eclipse.org/Jetty/Tutorial/Jetty_HelloWorld
(пример для 7й версии, но для нас пока не важно)
и 
http://en.wikipedia.org/wiki/Jetty_(web_server)
www.eclipse.org/jetty/documentation/current/
(без фанатизма)
Кроме того нам будет нужен шаблонизатор:
en.wikipedia.org/wiki/FreeMarker

ДЗ-2
1. При помощи Jetty запустить свой web сервер (при обращении на localhost:8080/ возвращать “Hello Server!”)
2. Написать class PageGenerator на основе freemarker. Написать страницу, которая перезапрашивает себя раз в секунду с сервера (пример с таймером).
3. Подключить библиотеку сервлетов для Jetty: 

<dependency>
    <groupId>org.eclipse.jetty</groupId>
    <artifactId>jetty-webapp</artifactId>
    <version>9.0.5.v20130815</version>
</dependency>

4. Написать class Frontend extends HttpServlet и обрабатывать в нем все запросы (context.addServlet(new ServletHolder(frontend), "/*"); Переписать “Hello server” на сервлетах.
5. Каждому пользователю (из каждого браузера) присваивать уникальный идентификатор, выводить его на всех страницах. Идентификатор хранить в HttpSession.
6. Подключить в Jetty выдачу статики. Создать страницу index.html с картинкой и возвращать ее при открытии страницы.
7. Сделать страницу с «авторизацией» пользователя. Пользователя нужно спросить имя и пароль и проверить их в объекте Frontend (можно захардкодить). Если пользователь узнан – вернуть ему его id.

ДЗ-3
1. Написать свой thread-pool. При старте приложения положить в контейнер N тредов и запустить их. В методе run() выводить в лог имя треда. Запустить приложение несколько раз и убедиться, что треды работают независимо друг от друга.
2. Расширить приложение из первого пункта — добавить в тред id, в логе выводить id треда, а не его имя. Метод run изменить так, чтобы треды писали в лог последовательно в порядке увеличения id (использовать wait() и notifyAll()). 
3. Сделать class Frontend implements Runnable
Добавить в класс переменную int handleCount = 0.
Запустить Frontend в отдельном потоке. В методе run() писать значение handleCount в лог каждые 5 секунд. 
В методах doGet() и doPost() кроме формирования страницы, увеличивать значение handleCount.

ДЗ-4
Изменить приложени так чтобы:
1. При первом запросе страницы приложение создает для пользователя Long sessionId и объект userSession и добавляет эти объекты в Map<Long, UserSession> sessionIdToUserSession,
после чего возвращает пользователю страницу с sessionId, а так же запрос «Введите свое имя».
2. Вместе с именем приложение получает от пользователя ранее переданный ему sessionId, находит по этому Id объект пользовательской сессии и записывает в него присланное имя. 
3. После изменения объекта userSession приложение отправляет пользователю страницу с sessionId и статусом «Ждите авторизации».
4. После отправки страницы приложение запрашивает у службы AccountService аутентификацию пользователя. Служба AccountService работает в отдельном потоке и может найти userId по имени пользователя (поиск может быть долгим, имитацию долгого поиска можно сделать через Thread.sleep(5000)).
5. Если пользователь запрашивает страницу раньше, чем AccountService нашел userId по имени, он получает страницу с sessionId и статусом «Ждите авторизации».
6. Если AccountService нашел userId, Frontend должен добавить userId в объект userSession соответствующего пользователя. 
При следующем обращении пользователь получит страницу «Здравствуйте: » + userName + " ваш userId: " + userId;

При старте приложение должно создавать два потока: Frontend и AccountService. Frontend должен отвечать на запросы пользователя из браузера, а AccountService обрабатывать запрос на авторизацию. «Общение» между потоками должно проходить через систему обмена сообщениями.
ДЗ-5
Подключить junit: 

<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.11</version>
</dependency>

1. Написать unit тесты для фронтенда и аккаунт сервера. 
2. Написать mock Frontend. 
3. Протестировать систему обмена сообщениями

ДЗ-6
1. Добавить еще один абонент и поток — GameMechanics.
2. Добавить адрес этого абонента в AddressService. 
3. Написать абстрактное сообщение MsgToGM и реализацию — MsgStartGameSession. 
Frontend должен посылать сообщение MsgStartGameSession на GameMechanics в тот момент, когда к серверу присоединилось достаточно пользователей для старта новой игры (например, 2 пользователя для игры в шахматы). Получив это сообщение, игровая механика должна создать игровую сессию для пользователей Id которых пришли в сообщении.
4. Написать сообщение на Frontend, и пересылать в нем из GameMechanics реплику состояния игровой сессии каждые 100ms (пока достаточно реализовать через Thread.sleep(100)).
5. Для проверки работы пересылки сообщений при старте игровой сессии запоминать время старта, пересылать из игровой механики текущую длительность игровой партии и показывать ее на странице. 
Получать текущее время в миллисекундах можно так:
Date date = new Date();
long currentTime = date.getTime();
в методе run() после обработки сообщений, для каждой игровой сессии вычислять время, прошедшее с ее начала и отправлять обновление на Frontend. 
6. Написать тесты на механику, обмен сообщениями с механикой и реплику.

ДЗ-7
Написать виртуальную файловую систему (VFS) со следующим интерфейсом:

public interface VFS {
    boolean isExist(String path);
    boolean isDirectory(String path);
    String getAbsolutePath(String file);
    byte[] getBytes(String file);
    String getUFT8Text(String file);
    Iterator<String> getIterator(String startDir);
} 

VFS НЕ должна загружать файлы в память при старте сервера. Задача этой системы скрывать детали работы с файлами. При желании можно написать mock реализацию in-memory VFS для тестов.

ДЗ-8
Написать ресурсную систему сервера (ResourceFactory). 
1. Все константы которые использует сервер вынести в ресурсные xml файлы. Написать классы, объекты которых можно восстановить на основе этих ресурсных xml файлов. 
2. Код, которые использует константу должен спрашивать у ResourceFactory объект ресурса по пути к файлу. Например:
ResourceFactory.instance().getResource("./data/Map.xml")
getResource(...) вернет объект по интерфейсу Resource, которые вызывающий код может преобразовать в конкретный тип MapResource. MapResource — контейнер констант которые описывают карты. Для каждой константы в этом классе должен быть get метод.
3. ResourceFactroy — должна быть singleton-ом. С инициализацией при старте сервера. Во время инициализации можно прочитать все ресурсы и закэшировать их объекты по пути к их файлам.

ДЗ-9
Написать DataBase сервис на основе JDBC API. Сервис должен получать сообщения от других модулей с запросами на сохранение или загрузку данных и отправлять сообщения с результатами. Сервис должен быть написан с применением шаблона DAO и DataSet-ом для каждой таблицы.
Database сервис можно использовать для сохранения идентификационных данных пользователя (соответствие имени пользователя и его id) и для сохранения результатов сыгранных партий.

ДЗ-10
Реализовать Database сервис из предыдущего задания через библиотеку Hibernate.
